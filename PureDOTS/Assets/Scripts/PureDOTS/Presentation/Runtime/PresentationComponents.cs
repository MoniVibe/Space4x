using Unity.Entities;
using Unity.Mathematics;

namespace PureDOTS.Presentation.Runtime
{
    public enum PresentationPrototype : byte
    {
        Villager = 0,
        ResourceNode = 1,
        Building = 2,
        Cloud = 3,
        Vegetation = 4,
        MiracleToken = 5,
        MiracleEffect = 6,
        HandCursor = 7,
        ThrowableToken = 8,
        Chunk = 9,
        Count
    }

    public static class PresentationRequestFlags
    {
        public const byte HasScaleOverride = 1 << 0;
        public const byte HasColorOverride = 1 << 1;
    }

    /// <summary>
    /// Request for an entity to receive a presentation instance generated by the presentation pipeline.
    /// </summary>
    public struct PresentationRequest : IComponentData
    {
        public PresentationPrototype Prototype;
        public float UniformScale;
        public float4 Color;
        public byte Flags;

        public static PresentationRequest Create(PresentationPrototype prototype, float uniformScale = 1f)
        {
            return new PresentationRequest
            {
                Prototype = prototype,
                UniformScale = uniformScale,
                Color = new float4(0f),
                Flags = uniformScale > 0f && math.abs(uniformScale - 1f) > math.EPSILON
                    ? PresentationRequestFlags.HasScaleOverride
                    : (byte)0
            };
        }

        public static PresentationRequest WithColor(PresentationPrototype prototype, float4 color, float uniformScale = 1f)
        {
            byte flags = PresentationRequestFlags.HasColorOverride;
            if (uniformScale > 0f && math.abs(uniformScale - 1f) > math.EPSILON)
            {
                flags |= PresentationRequestFlags.HasScaleOverride;
            }

            return new PresentationRequest
            {
                Prototype = prototype,
                UniformScale = uniformScale,
                Color = color,
                Flags = flags
            };
        }
    }

    /// <summary>
    /// Tag added once presentation has been generated for an entity.
    /// </summary>
    public struct PresentationAssignedTag : IComponentData { }

    /// <summary>
    /// Optional state for vegetation presentation to drive growth scaling.
    /// </summary>
    public struct VegetationPresentationState : IComponentData
    {
        public float NormalizedGrowth;
    }

    /// <summary>
    /// Optional state for miracle VFX tracking.
    /// </summary>
    public struct MiraclePresentationState : IComponentData
    {
        public float ActiveTimer;
        public float Lifetime;
        public byte IsActive;
    }

    /// <summary>
    /// Singleton containing indices that map presentation prototypes to mesh/material pairs in the render array.
    /// </summary>
    public struct PresentationRenderCatalog : IComponentData
    {
        public BlobAssetReference<PresentationRenderCatalogBlob> Blob;
    }

    public struct PresentationRenderCatalogBlob
    {
        public BlobArray<PresentationPrototypeEntry> Prototypes;
    }

    /// <summary>
    /// Tag on the singleton entity holding presentation configuration data.
    /// </summary>
    public struct PresentationConfigTag : IComponentData { }

    public struct PresentationPrototypeEntry
    {
        public int MeshIndex;
        public int MaterialIndex;
        public float3 DefaultScale;
        public float3 BoundsExtents;
        public float4 DefaultColor;
    }

    public struct HandCursorPresentationTag : IComponentData { }
}
